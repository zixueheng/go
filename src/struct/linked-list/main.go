package main

import "fmt"

// 1、单向链表
// 单向链表中每个结点包含两部分，分别是数据域和指针域，上一个结点的指针指向下一结点，依次相连，形成链表。

// 这里介绍三个概念：首元结点、头结点和头指针。
//     首元结点：就是链表中存储第一个元素的结点，如下图中 a1 的位置。
//     头结点：它是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以存储链表的长度或者其它的信息，也可以为空不存储任何信息。
//     头指针：它是指向链表中第一个结点的指针。若链表中有头结点，则头指针指向头结点；若链表中没有头结点，则头指针指向首元结点。

// 头指针   头结点       首元节点
// head -> data|地址 -> a1|地址 -> a2|地址 -> ... -> an|nil

// 头结点在链表中不是必须的，但增加头结点有以下几点好处：
//     增加了头结点后，首元结点的地址保存在头结点的指针域中，对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。
//     增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针，若链表为空的话，那么头结点的指针域为空。

// Node 节点
type Node struct {
	data int
	next *Node
}

// showNodes 遍历链表
func showNodes(p *Node) {
	for p != nil {
		fmt.Println(*p)
		p = (*p).next
	}
}

func main() {
	var head = new(Node) // 返回地址
	(*head).data = 1

	// var node1 = new(Node)
	// (*node1).data = 2
	// (*head).next = node1

	// var node2 = new(Node)
	// (*node2).data = 3
	// (*node1).next = node2

	// showNodes(head)
	// {1 0xc0000341f0}
	// {2 0xc000034200}
	// {3 <nil>}

	// 1、头部插入节点
	var tail *Node
	tail = head // tail用于记录头结点的地址，刚开始tail的的指针指向头结点
	// for i := 2; i <= 10; i++ {
	// 	node := Node{data: i}
	// 	node.next = tail // 将新插入的node的next指向头结点
	// 	tail = &node     // 重新赋值头结点
	// }
	// showNodes(tail) // 这里 tail 已指向最后一个插入的 Node，即链表队头，所以从 tail 开始循环
	// {10 0xc000034270}
	// {9 0xc000034260}
	// {8 0xc000034250}
	// {7 0xc000034240}
	// {6 0xc000034230}
	// {5 0xc000034220}
	// {4 0xc000034210}
	// {3 0xc000034200}
	// {2 0xc0000341f0}
	// {1 <nil>}

	// 2、尾部插入节点
	for i := 2; i <= 10; i++ {
		node := Node{data: i}
		(*tail).next = &node
		tail = &node // 将 tail 指向 新加入的节点，即 tail 下移
	}
	showNodes(head) // 这时tail 已指向最后一个节点 即链表队尾，所以从 head 开始 循环
	// {1 0xc0000341f0}
	// {2 0xc000034200}
	// {3 0xc000034210}
	// {4 0xc000034220}
	// {5 0xc000034230}
	// {6 0xc000034240}
	// {7 0xc000034250}
	// {8 0xc000034260}
	// {9 0xc000034270}
	// {10 <nil>}

	// 注意：
	// 在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以速度较慢。
	// 而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。

	// 但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。
	// 因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。

}

// 2、循环链表
// 循环链表是一种特殊的单链表。
// 循环链表跟单链表唯一的区别就在尾结点。单向链表的尾结点指针指向空地址，表示这就是最后的结点了，而循环链表的尾结点指针是指向链表的头结点，它像一个环一样首尾相连，所以叫作“循环”链表。
// head -> data|地址 -> a1|地址 -> a2|地址 -> ... -> an|地址
// 和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。
// 比如著名的约瑟夫问题，尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。

// 3、双向链表
// 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。
// head -> nil|data|next <-> prev|a1|next <-> prev|a2|next <-> ... <-> prev|an|nil
// 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。
// 虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。
